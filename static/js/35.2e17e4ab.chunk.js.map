{"version":3,"sources":["views/Nft/market/index.tsx","state/nftMarket/hooks.ts"],"names":["Home","lazy","NftProfile","Collection","Collections","Market","account","useWeb3React","initializationState","useGetNFTInitializationState","useFetchCollections","NFTMarketInitializationState","INITIALIZED","exact","path","nftsBaseUrl","to","toLowerCase","dispatch","useAppDispatch","useEffect","fetchCollections","useFetchCollection","collectionAddress","fetchCollection","useFetchByBunnyIdAndUpdate","bunnyId","useSelector","state","nftMarket","data","loadingState","latestPancakeBunniesUpdateAt","isUpdatingPancakeBunnies","existingBunniesInState","useGetAllBunniesByBunnyId","existingTokensWithBunnyId","map","nft","tokenId","allPancakeBunnies","useNftsFromCollection","pancakeBunniesAddress","allExistingPBTokenIds","firstBunny","length","existingMetadata","useMemo","name","description","collection","collectionName","image","fetchMorePancakeBunnies","orderDirection","fetchNewPBAndUpdateExisting","useLoadingState","useGetCollections","collections","useGetCollection","checksummedCollectionAddress","isAddress","nfts","filter","attributes","value","marketData","isTradable","useUserNfts","user","useGetNftFilters","filters","activeFilters","useGetNftFilterLoadingState","useGetNftOrdering","ordering","useGetNftShowOnlyOnSale","showOnlyOnSale"],"mappings":"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","file":"static/js/35.2e17e4ab.chunk.js","sourcesContent":["import React, { lazy } from 'react'\nimport { Redirect, Route } from 'react-router-dom'\nimport { useWeb3React } from '@web3-react/core'\nimport { useFetchCollections, useGetNFTInitializationState } from 'state/nftMarket/hooks'\nimport PageLoader from 'components/Loader/PageLoader'\nimport { NFTMarketInitializationState } from 'state/nftMarket/types'\nimport { nftsBaseUrl } from './constants'\n\nconst Home = lazy(() => import('./Home'))\nconst NftProfile = lazy(() => import('./Profile'))\nconst Collection = lazy(() => import('./Collection'))\nconst Collections = lazy(() => import('./Collections'))\n\nconst Market = () => {\n  const { account } = useWeb3React()\n  const initializationState = useGetNFTInitializationState()\n\n  useFetchCollections()\n\n  if (initializationState !== NFTMarketInitializationState.INITIALIZED) {\n    return <PageLoader />\n  }\n\n  return (\n    <>\n      <Route exact path={nftsBaseUrl}>\n        <Home />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/collections`}>\n        <Collections />\n      </Route>\n      <Route path={`${nftsBaseUrl}/collections/:collectionAddress`}>\n        <Collection />\n      </Route>\n      <Route path={`${nftsBaseUrl}/profile/:accountAddress?`}>\n        <NftProfile />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/profile`}>\n        <Redirect to={`${nftsBaseUrl}/profile/${account?.toLowerCase() || ''}`} />\n      </Route>\n    </>\n  )\n}\n\nexport default Market\n","import { useEffect, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { useAppDispatch } from 'state'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport { isAddress } from 'utils'\nimport { fetchCollection, fetchCollections, fetchNewPBAndUpdateExisting } from './reducer'\nimport { State } from '../types'\nimport { NftToken, UserNftsState } from './types'\n\nconst MAX_GEN0_ID = 4\n\nexport const useFetchCollections = () => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollections())\n  }, [dispatch])\n}\n\nexport const useFetchCollection = (collectionAddress: string) => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollection(collectionAddress))\n  }, [dispatch, collectionAddress])\n}\n\n// Returns a function that fetches more NFTs for specified bunny id\n// as well as updating existing PB NFTs in state\n// Note: PancakeBunny specific\nexport const useFetchByBunnyIdAndUpdate = (bunnyId: string) => {\n  const dispatch = useAppDispatch()\n\n  const { latestPancakeBunniesUpdateAt, isUpdatingPancakeBunnies } = useSelector(\n    (state: State) => state.nftMarket.data.loadingState,\n  )\n\n  // Extra guard in case market data shifts\n  // we don't wanna fetch same tokens multiple times\n  const existingBunniesInState = useGetAllBunniesByBunnyId(bunnyId)\n  const existingTokensWithBunnyId = existingBunniesInState ? existingBunniesInState.map((nft) => nft.tokenId) : []\n\n  const allPancakeBunnies = useNftsFromCollection(pancakeBunniesAddress)\n  const allExistingPBTokenIds = allPancakeBunnies ? allPancakeBunnies.map((nft) => nft.tokenId) : []\n\n  const firstBunny = existingBunniesInState.length > 0 ? existingBunniesInState[0] : null\n\n  // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\n  const existingMetadata = useMemo(() => {\n    return firstBunny\n      ? {\n          name: firstBunny.name,\n          description: firstBunny.description,\n          collection: { name: firstBunny.collectionName },\n          image: firstBunny.image,\n        }\n      : null\n  }, [firstBunny])\n\n  // This fetches more bunnies when called\n  const fetchMorePancakeBunnies = (orderDirection: 'asc' | 'desc') => {\n    dispatch(\n      fetchNewPBAndUpdateExisting({\n        bunnyId,\n        existingTokensWithBunnyId,\n        allExistingPBTokenIds,\n        existingMetadata,\n        orderDirection,\n      }),\n    )\n  }\n\n  return { isUpdatingPancakeBunnies, latestPancakeBunniesUpdateAt, fetchMorePancakeBunnies }\n}\n\nexport const useLoadingState = () => {\n  return useSelector((state: State) => state.nftMarket.data.loadingState)\n}\n\nexport const useGetCollections = () => {\n  return useSelector((state: State) => state.nftMarket.data.collections)\n}\n\nexport const useGetCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const collections = useGetCollections()\n  return collections[checksummedCollectionAddress]\n}\n\nexport const useNftsFromCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[checksummedCollectionAddress])\n  return nfts\n}\n\nexport const useGetAllBunniesByBunnyId = (bunnyId: string) => {\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[pancakeBunniesAddress])\n  return nfts ? nfts.filter((nft) => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : []\n}\n\nexport const useGetNFTInitializationState = () => {\n  return useSelector((state: State) => state.nftMarket.initializationState)\n}\n\nexport const useUserNfts = (): UserNftsState => {\n  return useSelector((state: State) => state.nftMarket.data.user)\n}\n\nexport const useHasGen0Nfts = (): boolean => {\n  const userNfts = useSelector((state: State) => state.nftMarket.data.user)\n  return userNfts.nfts.some((nft) => nft.attributes && Number(nft.attributes[0]?.value) <= MAX_GEN0_ID)\n}\n\nexport const useGetNftFilters = () => {\n  return useSelector((state: State) => state.nftMarket.data.filters.activeFilters)\n}\n\nexport const useGetNftFilterLoadingState = () => {\n  return useSelector((state: State) => state.nftMarket.data.filters.loadingState)\n}\n\nexport const useGetNftOrdering = () => {\n  return useSelector((state: State) => state.nftMarket.data.filters.ordering)\n}\n\nexport const useGetNftShowOnlyOnSale = () => {\n  return useSelector((state: State) => state.nftMarket.data.filters.showOnlyOnSale)\n}\n"],"sourceRoot":""}